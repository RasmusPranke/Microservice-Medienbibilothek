\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{listings}
\usepackage{color}

\definecolor{backcolour}{RGB}{253, 246, 227}
\definecolor{codeorange}{RGB}{203, 75, 22}
\definecolor{codeyellow}{RGB}{181, 137, 0}
\definecolor{codecyan}{RGB}{42, 161, 152}
\definecolor{codegray}{RGB}{147, 161, 161}
\definecolor{codebasic}{RGB}{101, 123, 131}

\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolour},
  commentstyle=\color{codeorange},
  keywordstyle=\color{codeyellow},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codecyan},
  basicstyle=\footnotesize\ttfamily\color{codebasic},
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  keepspaces=true,
  numbers=left,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2,
  language=Java
}
\lstset{style=mystyle}

\begin{document}

\section{Was sind Microservices?}

Microservices sind ein relativ neuer Ansatz der Softwarearchitektur, bei dem Software in viele kleine, unabhängige Prozesse aufgespalten wird\cite{OMA}.
Jeder dieser übernimmt einen kleinen Anteil der Gesamtfunktionalität und kommuniziert mit anderen Services, um diesen zu Erfüllen\cite{EMMA}.

\section{Vor- und Nachteile von Microservices}

Microservices glänzen vor allem durch eine bedeutend stärkere Kapselung als es bei monolithischer Software normalerweise der Fall ist.
Durch die Trennung in verschiedene Prozesse können die Umgebungen der einzelnen Services auf ihren jeweiligen Aufgabenbereich angepasst werden.
Als Komponenten der Gesamtsoftware sind sie dadurch auch nicht mehr an einen gemeinsamen Technologiestack gebunden und müssen sich auch keine Hardware mehr teilen.
Die einzelnen Services können weitestgehend unabhängig voneinander verändert und ausgetauscht werden.

Außerdem erleichtern Microservices die horizontale Skalierung, da die inherente Trennung in einzelne Prozesse vergleichsweise einfache Duplikation der Instanzen erlaubt.
Dieses führt gleichzeitig auch zu einer besseren Fehlertoleranz, da damit jede Komponente redundant vorhanden ist.

Allerdings kommen diese Vorteile nicht ohne Kosten.
Microservices sind verteilte Systeme, welche in der Praxis aus vielen Gründen schwerer zu entwickeln sind.
Dazu zählt zum einem, dass sie Infrastruktur benötigen, und dass sie schwerer zu testen sind.
Da die Kommunikation der Services über Netzwerke stattfindet, muss außerdem eine signifikante Latenz beachtet werden.
Zusätzlich muss während der Designphase auch entschieden werden wie die Funktionalität in Services aufgeteilt wird, welches die größte Hürde beim entwerfen von Microservices darstellt.\cite{OMA}

\section{Microservices mit Spring}

Spring ist eine Sammlung von Frameworks zur Unterstützung der Entwicklung von verschiedensten Systemen in Java.
Manche dieser Frameworks bieten eine eigene Funktionalität, andere helfen dabei, Technologien die nicht zu Spring gehören in das zu entwickelnde System einzubinden.

Viele der Angebotenen Frameworks sind nützlich für das Entwickeln von Microservices.
Dabei lässt sich unterscheiden zwischen Solchen, die in vielen Arten von Systemen angewandt werden können, und Solchen, die speziell auf die Anwendung in microservicebasierten Systemen zugeschnitten sind.

\subsection{Allgemein verwendbare Frameworks}

Dies sind Frameworks, die bei der Entwicklung eines microservicebasierten Systems verwendbar, aber nicht speziell auf diese Architektur zugeschnitten sind.

\begin{description}
    \item[Spring Framework] enthält generische Funktionen wie Dependency Injection, Events, Testunterstützung und vieles mehr.
    \item[Spring Data] ist kein einzelnes Framework, sondern eine Sammlung von Frameworks welche die Datenverwaltung unterstützen.
    \begin{description}
        \item[Spring Data Commons] implementiert einen repositorybasierten Ansatz zur Datenverwaltung.
        \item[Spring Data JPA/JDBC/\ldots] ermöglicht die Nutzung von spezifischen Datenverwaltungstechnologien mit Spring Data.
    \end{description}

    \item[Spring Cloud] ist eine Sammlung von Frameworks die das Entwickeln von verteilten Systemen aller Art unterstützen.
    \begin{description}
        \item[Spring Cloud Config] ermöglicht das zentrale Konfigurieren von verteilten Systemkomponenten.
        \item[Spring Cloud Security] sichert die Authentifizierung von Nutzern in verteilten Systemen ab und ermöglicht das Propagieren des Authentifikationsstatus.
        \item[Spring Cloud Sleuth] erlaubt es, den Datenverkehr innerhalb eines verteilten Systems zu beobachten.
    \end{description}
\end{description}

\subsection{Microservicespezifische Frameworks}

Dies sind Frameworks, die speziell für die Entwicklung von microservicebasierten Systemen entworfen sind.

\begin{description}
    \item[Spring Cloud] s.o.
    \begin{description}
        \item[Spring Cloud Netflix] unterstützt die Integration folgender Netflix Open Source Software:
        \begin{description}
            \item[Eureka] ermöglicht es Services zu registrieren, sodass Clients diese anfragen und entdecken können.
            \item[Hystrix] hilft damit umzugehen, wenn benötigte Services nicht erreichbar sind.
            \item[Ribbon] verteilt die Last der Anfragen auf verfügbare Instanzen eines Services. (Load Balancing)
            \item[Zuul] verwaltet und überwacht Verbindungen zu den Microservices und nimmt Anfragen von Clients bzw. von Edge Services entgegen.
        \end{description}

        \item[Spring Cloud Stream] unterstützt das Entwickeln von eventgetriebenen Microservices die über Apache Kafka oder RabbitMQ kommunizieren.
        \item[Spring Cloud Task] ermöglicht das Entwickeln von kurzlebigen Microservices die on-demand eine Aufgabe ausführen.
    \end{description}
\end{description}

\subsection{Andere Tools}

Verwendbare Tools die von Spring angeboten werden, aber keine Framework Libraries sind.

\begin{description}
    \item[Spring Boot] ist eine Library, die als Startpunkt für das schnelle aufsetzen von Springbasierten Anwendungen dient.
    \item[Spring Initializr] initialisiert ein Spring Boot Projekt mit benötigten Dependencies und richtet Build Configuration mit Gradle oder Maven ein.
    \item[Spring Cloud Data Flow] ist ein Toolkit, welches das Vernetzen von Microservices, die mit Spring Cloud Stream oder Task erstellt wurden, anhand einer GUI oder Shell Anwendung ermöglicht.
\end{description}

\section{Microservices mit Spring am Beispiel der SE2-Medienbibilothek}

Wir werden im folgenden Abschnitt die Medienbibliothek aus unserer Vorlseung Softwareentwicklung 2 in eine Microservice-Architektur überführen und anhand dessen die Vorteile der Frameworks hervorheben.

\subsection{Aufteilen in Microservices}

Da die Medienbibliothek den WAM-Ansatz verfolgt ist sie bereits in weitesgehend unabhängige Services unterteilt.
Wir können jeden davon in einen eigenen Microservice übersetzen und müssen uns (bei dieser Größenordnung) keine weiteren Gedanken um die Unterteilung machen.

\subsection{Spring Boot}

Um Spring zu verwenden muss die Anwendung als Spring Boot Application markiert und gestartet werden:

\begin{lstlisting}
@SpringBootApplication
public class MedienbestandServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(
        	MedienbestandServiceApplication.class, args);
    }
}
\end{lstlisting}

Die \texttt{@SpringBootApplication}-Annotation markiert die Klasse als mit Spring Boot ausführbar, wodurch sie mit \texttt{SpringApplication.run} ausgeführt werden kann.

Spring durchsucht daraufhin das aktuelle Paket sowie alle Sub-Pakete nach bestimmten Annotationen, welche andere Klassen als Module der Anwendung deklarieren.
Einige davon werden in den folgenden Sektionen angesprochen.

Hier zeigt sich auch eine der größten Stärken von Spring: Wir müssen uns nicht damit auseinandersetzen, wie unser Code geladen wird.
Spring übernimmt die Komposition des Services und erleichtert diese damit um ein Vielfaches.

\subsection{Migration zu Datenbanken}

Die Medienbibliothek verwendet einfache Textdateien als Datenbanken und unterstützt keine Schreiboperationen auf diese.
Da dies in keinster Weise repräsentativ für reale Anwendungen ist, ist unser erster Schritt, echte relationale Datenbanken zu verwenden.

Spring stellt dafür eine Reihe an Frameworks unter dem Namen \texttt{Spring Data} bereit:
\begin{itemize}
        \item{Spring Data Commons} {implementiert einen Repositorybasierten Ansatz zur Datenverwaltung und bildet die Grundlage für alle weiteren Spring Data Module.}
        \item{Spring Data JPA/JDBC/\ldots} ermöglicht die Nutzung von spezifischen Datenverwaltungstechnologien mit Spring Data.
\end{itemize}

Jedes dieser Module bezieht sich dabei auf eine spezifische Technologie.
Da wir uns für eine relationale Datenbank entschieden haben sind für uns lediglich JDBC und JPA interessant.

\subsubsection{JDBC}

JDBC abstrahiert die Verbindung zu einer Datenbank und stellt Methoden bereit, um via SQL auf diese zuzugreifen.
Um via JDBC auf eine Datenbank zuzugreifen benötigt man lediglich eine \texttt{JdbcTemplate}-Deklaration mit der \texttt{Autowired}-Annotation:

\begin{lstlisting}
public class Exampleclass {
    @Autowired
    JdbcTemplate jdbcTemplate;
}
\end{lstlisting}

Spring sucht sich nun anhand der vorhandenen Module sowie den Einstellungsdateien alle Informationen zur Datenbank zusammen, stellt eine Verbindung zu dieser her und stellt diese mithilfe dieser \texttt{JdbcTemplate} automatisch (dank der \texttt{Autowired}-Annotation) bereit.
Damit reduziert sich der Aufwand, eine Datenbank zu benutzen, auf das Schreiben und Auswerten der Queries:

\begin{lstlisting}
log.info("Creating tables");

dbcTemplate.execute("DROP TABLE customers IF EXISTS");
jdbcTemplate.execute("CREATE TABLE customers(" + "id SERIAL, first_name VARCHAR(255), last_name VARCHAR(255))");

// Uses JdbcTemplate's batchUpdate operation to bulk load data
jdbcTemplate.batchUpdate("INSERT INTO customers(first_name, last_name) VALUES (?,?)", [["Josh", "Doe"], ["Steffen", "Harb"]]);

// Selects based on the first name.
jdbcTemplate.query("SELECT id, first_name, last_name FROM customers WHERE first_name = ?", new Object[] { "Josh" }, (rs, rowNum) -> new Customer(rs.getLong("id"), rs.getString("first_name"), rs.getString("last_name"))).forEach(customer -> log.info(customer.toString()));
\end{lstlisting}

\subsubsection{JPA}

JPA abstrahiert wie JDBC die Datenbankverbindung, stellt aber gleichzeitig einen Wrapper für Datenbankabfragen dar. Eine JPA-Kompatible Datenbank lässt sich in einer einzelnen Interface-Deklaration definieren:

\begin{lstlisting}
public interface CDRepo extends CrudRepository<CD, CD.CDId> {}
\end{lstlisting}

Dieses Interface deklariert eine Datenbank, welche \texttt{CD}s anhand des Schlüssels \texttt{CD.CDId} speichert.
Sie kann wie die \texttt{JdbcTemplate} mit der \texttt{Autowired}-Annotation automatisch in Klassen injeziert werden und stellt verschieden Grundlegende Operationen bereit.
JPA erlaubt keine freien SQL-Queries und ist damit deutlich eingeschränkter als \texttt{JDBC}.

\subsection{Spring Data Commons}

Unabhängig davon, welche der bedien Technologien verwendet werden, müssen die zu verwendenden Datenklassen als für die Datenbank nutzbar deklariert werden.
Im Falle einer einfachen Datenklasse muss man dafür lediglich die \texttt{@Entity}-Annotation setzen und die Schlüsselfelder mit der \texttt{@Id}-Annotation versehen.
In der Medienbibilothek allerdings werden die Eigenschaften der Medien vererbt. 

\subsection{Spring Cloud Stream}

Spring Cloud Stream (SCS) bietet Unterstützung dafür Microservices zu entwickeln, die sich über einen Messagingservice verbinden.
Bisher unterstützt SCS dafür Apache Kafka und RabbitMQ, für unser Projekt haben wir uns für Apache Kafka entschieden.
SCS bietet allerdings eine allgemeine Syntax, welche von dem gewählten Messagingservice unabhängig ist.

Damit ein Microservice mit dem Messagingservice interagieren kann, muss ein Interface angeboten werden welches die Input- und Outputkanäle des Service definiert.
Falls es nur jeweils maximal einen Input- und Outputkanal geben soll, reicht es die in SCS vordefinierten Interfaces \texttt{Sink}, \texttt{Source} und \texttt{Processor} zu verwenden.
Dabei definiert \texttt{Sink} einen Inputkanal, \texttt{Source} einen Outputkanal und \texttt{Processor} erbt von beiden.

Methoden, welche mit dem Messagingservice interagieren sollen, müssen ebenfalls entsprechend annotiert werden.
Ein simpler Service der eine Nachricht erhält, anhand dessen Operationen ausführt und dann eine Nachricht zurück/weiter schickt, sähe folgendermaßen aus:
\begin{lstlisting}
@EnableBinding{Processor}
public class MedienProcessor {
    ...

    @StreamListener{Processor.INPUT}
    @SendTo{Processor.OUTPUT}
    public Medium processMedium(Medium medium) {
        ...
        return medium;
    }
}
\end{lstlisting}

Das kodieren und dekodieren der Java-Objekte zu Nachrichten inklusive entsprechenden Headern und zurück wird dabei automatisch von dem Framework erledigt.

In unserem Projekt wollen wir alle Arten von Medien über einen Kanal senden.
Damit diese korrekt dekodiert werden können, definieren wir einen eigenen Header, welcher den Typ des gesendeten Mediums angibt, und prüfen diesen beim Erhalten einer Nachricht, um das Medium entsprechend behandeln zu können.
Um den entsprechenden Header beim Verschicken der Nachricht setzen zu können, müssen wir die automatische Nachrichtengenerierung umgehen:
\begin{lstlisting}
@SendTo(Source.OUTPUT)
public Message<?> sendeMedium(Medium medium) {
    return MessageBuilder
            .withPayload(medium)
            .setHeader("type", medium.getClass().getSimpleName())
            .build();
}
\end{lstlisting}

Beim Empfangen der Nachrichten können wir über ein Argument der Annotation sicher stellen, dass diese anhand des Werts unseres Headers von der richtigen Methode entgegen genommen wird.
\begin{lstlisting}
@StreamListener(target = Sink.INPUT,
                condition = "headers['type']=='CD'")
public void fuegeCdEin(CD cd) {
    ...
}
\end{lstlisting}

Der Wert von \texttt{condition} ist ein Spring Expression Language (SpEL) Ausdruck.

Nachdem die Methoden zum Senden, Empfangen, und Verarbeiten der Nachrichten also fertig sind, müssen die Verbindungen der Microservices zu Kafka oder RabbitMQ konfiguriert werden.
In den meisten Fällen kann die manuelle Konfigurierung aber komplett umgangen werden, durch das verwenden von Spring Cloud Data Flow.
\end{document}
